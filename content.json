{"posts":[{"title":"Drools 学习","text":"简介规则引擎 规则引擎由推理引擎发展而来，是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据业务规则做出业务决策。需要注意的是规则引擎并不是一个具体的技术框架，而是指的一类系统，即业务规则管理系统。目前市面上具体的规则引擎产品有：drools、VisualRules、iLog等 应用场景 业务领域 示例 财务决策 贷款发放，征信系统 票价计算 航空，传播，火车及其他公共汽车运输 促销平台系统 满减，打折，加价购 Drools Drools 是一款由 JBoss 组织提供的基于 Java 语言开发的开源规则引擎，可以将复杂且多变的业务规则从硬编码中解放出来，以规则脚本的形式存放在文件或特定的存储介质中，使得业务规则的变更不需要修改项目代码，重启服务器就可以在线上环境立即生效。 官网介绍： Drools is a set of projects focusing on intelligent automation and decision management, most notably providing a forward-chaining and backward-chaining inference-based rule engine, DMN decisions engine and other projects. A rule engine is a fundamental building block to create an expert system which, in artificial intelligence, is a computer system that emulates the decision-making ability of a human expert. 官网地址 https://docs.drools.org/latest/drools-docs/drools/introduction/index.html Drools 规则引擎组成 Working Memory(工作内存) Rule Base(规则库) Inference Engine(推理引擎)：Pattern Matcher(匹配器)，Agenda(议程)，Execution Engine(执行引擎) Working Memory：工作内存，drools规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，所以我们开发的应用程序只需要将我们的数据插入到Working Memory中即可。 Fact：事实，是指在drools 规则应用当中，将一个普通的JavaBean插入到Working Memory后的对象就是Fact对象，Fact对象是我们的应用和规则引擎进行数据交互的桥梁或通道。 Rule Base：规则库，我们在规则文件中定义的规则都会被加载到规则库中。 Pattern Matcher：匹配器，将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，匹配成功的规则将被激活并放入Agenda中。 Agenda：议程，用于存放通过匹配器进行模式匹配后被激活的规则。 Execution Engine：执行引擎，执行Agenda中被激活的规则。 执行过程 将数据 Fact 输入至工作内存中(Working Memory) 使用Pattern Matcher 将规则库中的规则和数据 Fact 进行比较 如果执行规则存在冲突(conflict)，即同时激活了多个规则，将冲突规则放入冲突集合中 解决冲突，将激活的规则按顺序放入Agenda中 执行Agenda中规则。重复2～5，直到执行完毕Agenda中的所有规则 drl 文件 drl 文件是Drools 规则文件，全称是Drools Rule Language 规则文件内容结构 1234567891011package rulesimport com.elliot.spring.demo.drools.entity.BookDiscount;rule &quot;book_discount1&quot; when $book:BookDiscount(originalPrice &lt; 100) then System.out.println(&quot;book discount1&quot;); $book.setDiscountPrice($book.getOriginalPrice());end 关键字 描述 package 包名，逻辑上的路径 import 可以导入类或静态方法 global 全局变量 function 自定义函数 query 查询 rule end 规则体 规则体语法结构 规则体是规则文件内容中的重要组成部分，是进行业务规则判断、处理业务结果的部分。 规则体语法结构如下： 1234567rule &quot;ruleName&quot; attributes when LHS then RHSend rule：关键字，表示规则开始，参数为规则的唯一名称。 attributes：规则属性，是rule与when之间的参数，为可选项。 when：关键字，后面跟规则的条件部分。 LHS(Left Hand Side)：是规则的条件部分的通用名称。它由零个或多个条件元素组成。如果LHS为空，则它将被视为始终为true的条件元素。 （左手边） then：关键字，后面跟规则的结果部分。 RHS(Right Hand Side)：是规则的后果或行动部分的通用名称。 （右手边） end：关键字，表示一个规则结束。 Pattern模式匹配 Drools中的匹配器可以将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，那么我们就需要在规则体的LHS部分定义规则并进行模式匹配。LHS部分由一个或者多个条件组成，条件又称为pattern。 pattern的语法结构为：绑定变量名:Object(Field约束) 1234567891011package rulesimport com.elliot.spring.demo.drools.entity.BookDiscount;rule &quot;book_discount1&quot; when $book:BookDiscount(originalPrice &lt; 100) then System.out.println(&quot;book discount1&quot;); $book.setDiscountPrice($book.getOriginalPrice());end 比较操作符 符号 说明 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 == 等于 != 不等于 contains 检查一个Fact对象的某个属性值是否包含一个指定的对象值 not contains 检查一个Fact对象的某个属性值是否不包含一个指定的对象值 memberOf 判断一个Fact对象的某个属性是否在一个或多个集合中 not memberOf 判断一个Fact对象的某个属性是否不在一个或多个集合中 matches 判断一个Fact对象的属性是否与提供的标准的Java正则表达式进行匹配 not matches 判断一个Fact对象的属性是否不与提供的标准的Java正则表达式进行匹配 1.contains | not contains语法结构 Object(Field[Collection/Array] contains value) Object(Field[Collection/Array] not contains value) 2.memberOf | not memberOf语法结构 Object(field memberOf value[Collection/Array]) Object(field not memberOf value[Collection/Array]) 3.matches | not matches语法结构 Object(field matches “正则表达式”) Object(field not matches “正则表达式”) contain是前面包含后面，memberOf是后面包含前面。 Drools 内置方法 1.update 方法update 方法作用是更新工作内存中的数据，并让相关的规则重新匹配。 2.insert 方法insert 方法作用是向工作内存中插入数据，并让相关规则重新匹配。 3.retract 方法retract 方法作用是删除工作内存中的数据，并让相关规则重新匹配。 规则属性 1234567rule &quot;ruleName&quot; attributes //属性名 when LHS then RHSend 属性名 说明 salience 指定规则执行优先级 dialect 指定规则使用的语言类型，取值为java和mvel enabled 指定规则是否启用 date-effective 指定规则生效时间 date-expires 指定规则失效时间 activation-group 激活分组，具有相同分组名称的规则只能有一个规则触发 agenda-group 议程分组，只有获取焦点的组中的规则才有可能触发 timer 定时器，指定规则触发的时间 auto-focus 自动获取焦点，一般结合agenda-group一起使用 no-loop 防止死循环 1.salience属性salience属性用于指定规则的执行优先级，取值类型为Integer。数值越大越优先执行。每个规则都有一个默认的执行顺序，如果不设置salience属性，规则体的执行顺序为由上到下。 2.dialect属性dialect属性用于指定当前规则使用的语言类型，取值为java和mvel，默认值为java。 3.enabled属性enabled属性对应的取值为true和false，默认值为true。用于指定当前规则是否启用，如果设置的值为false则当前规则无论是否匹配成功都不会触发 4.date-effective属性date-effective属性用于指定规则的生效时间，即只有当前系统时间大于等于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。 5.date-expires属性date-expires属性用于指定规则的失效时间，即只有当前系统时间小于设置的时间或者日期规则才有可能触发。默认日期格式为：dd-MMM-yyyy。用户也可以自定义日期格式。 6.agenda-group属性agenda-group属性为议程分组，属于另一种可控的规则执行方式。用户可以通过设置agenda-group来控制规则的执行，只有获取焦点的组中的规则才会被触发。 7.timer属性 timer属性可以通过定时器的方式指定规则执行的时间，使用方式有两种： 方式一： 1timer (int: &lt;initial delay&gt; &lt;repeat interval&gt;?) 此种方式遵循java.util.Timer对象的使用方式，第一个参数表示几秒后执行，第二个参数表示每隔几秒执行一次，第二个参数为可选。 方式二： 1timer(cron: &lt;cron expression&gt;) 此种方式使用标准的unix cron表达式的使用方式来定义规则执行的时间。 8.auto-focus属性auto-focus属性为自动获取焦点，取值类型为Boolean，默认值为false。一般结合agenda-group属性使用，当一个议程分组未获取焦点时，可以设置auto-focus属性来控制。 9.no-loop属性no-loop属性用于防止死循环，当规则通过update之类的函数修改了Fact对象时，可能使当前规则再次被激活从而导致死循环。取值类型为Boolean，默认值为false。 Drools 高级语法 关键字 描述 package 包名，只限于逻辑上的管理，同一个包名下的查询或者函数可以直接调用 import 用于导入类或者静态方法 global 全局变量 function 自定义函数 query 查询 rule end 规则体 1.global global关键字用于在规则文件中定义全局变量，它可以让应用程序的对象在规则文件中能够被访问。可以用来为规则文件提供数据或服务。语法结构为：global 对象类型 对象名称 在使用global定义的全局变量时有两点需要注意： (1).如果对象类型为包装类型时，在一个规则中改变了global的值，那么只针对当前规则有效，对其他规则中的global不会有影响。可以理解为它是当前规则代码中的global副本，规则内部修改不会影响全局的使用。 (2).如果对象类型为集合类型或JavaBean时，在一个规则中改变了global的值，对java代码和所有规则都有效。 123456789101112131415161718192021222324package globals.rulesglobal java.lang.Integer countglobal java.util.List list//global 只在当前规则中生效rule &quot;global_1&quot;whenthen count += 10; System.out.println(&quot;count = &quot; + count);endrule &quot;global_2&quot;whenthen System.out.println(&quot;count = &quot; + count);endrule &quot;global_3&quot;whenthen System.out.println(list.get(0)); System.out.println(&quot;list length is &quot; + list.size());end 12345678@Testpublic void testGlobal() { kieSession.setGlobal(&quot;count&quot;, 10); kieSession.setGlobal(&quot;list&quot;, Arrays.asList(1, 2, 3)); kieSession.fireAllRules(new RuleNameStartsWithAgendaFilter(&quot;global&quot;)); kieSession.dispose();} 2.query 查询 query查询提供了一种查询working memory中符合约束条件的Fact对象的简单方法。它仅包含规则文件中的LHS部分，不用指定“when”和“then”部分并且以end结束。具体语法结构如下： 123query 查询的名称(可选参数) LHSend 1234567891011121314151617181920query &quot;queryTest&quot;(String name) $staff:Staff(name == &quot;mike&quot;)end@Testpublic void testQuery() { Staff staff = new Staff(); staff.setName(&quot;mike&quot;); staff.setLevel(1); staff.setSalary(1000); kieSession.insert(staff); kieSession.fireAllRules(); QueryResults queryResults = kieSession.getQueryResults(&quot;queryTest&quot;, &quot;mike&quot;); for (QueryResultsRow queryResult : queryResults) { Staff staff1 = (Staff) queryResult.get(&quot;$staff&quot;); System.out.println(&quot;staff: &quot; + staff1.getName() + &quot; level: &quot; + staff1.getLevel() + &quot; salary:&quot; + staff1.getSalary()); } kieSession.dispose();} 3.function 函数function关键字用于在规则文件中定义函数，就相当于java类中的方法一样。可以在规则体中调用定义的函数。使用函数的好处是可以将业务逻辑集中放置在一个地方，根据需要可以对函数进行修改。 函数定义的语法结构如下： 123function 返回值类型 函数名(可选参数){ //逻辑代码} 1234567891011121314151617181920package functions.rulesfunction int getSalary(int salary) { return salary + 1000;}rule &quot;function_1&quot;whenthen int salary = getSalary(1000); System.out.println(&quot;salary: &quot; + salary );end@Testpublic void testFunction() { kieSession.fireAllRules(new RuleNameStartsWithAgendaFilter(&quot;function&quot;)); kieSession.dispose();} 4.LHS、RHS加强 (1).复合值限制in/not in复合值限制是指超过一种匹配值的限制条件，类似于SQL语句中的in关键字。Drools规则体中的LHS部分可以使用in或者not in进行复合值的匹配。具体语法结构如下：Object(field in (比较值1,比较值2…)) 举例： 12$s:Student(name in (&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;))$s:Student(name not in (&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;)) (2).条件元素eval eval用于规则体的LHS部分，并返回一个Boolean类型的值。语法结构如下：eval(表达式) 举例： 123eval(true)eval(false)eval(1 == 1) (3).条件元素not not用于判断Working Memory中是否存在某个Fact对象，如果不存在则返回true，如果存在则返回false。语法结构如下：not Object(可选属性约束) 举例： 12not Student()not Student(age &lt; 10) (4).条件元素exists exists的作用与not相反，用于判断Working Memory中是否存在某个Fact对象，如果存在则返回true，不存在则返回false。语法结构如下：exists Object(可选属性约束)注意：当向Working Memory中加入多个满足条件的Fact对象时，使用了exists的规则执行一次，不使用exists的规则会执行多次。 举例： 12exists Student()exists Student(age &lt; 10 &amp;&amp; name != null) (5).规则继承extend规则之间可以使用extends关键字进行规则条件部分的继承，类似于java类之间的继承。 (6).halthalt方法的作用是立即终止后面所有规则的执行。 1234567891011121314package testhaltrule &quot;rule_halt_1&quot; when then System.out.println(&quot;规则：rule_halt_1触发&quot;); drools.halt();//立即终止后面所有规则执行end//当前规则并不会触发，因为上面的规则调用了halt方法导致后面所有规则都不会执行rule &quot;rule_halt_2&quot; when then System.out.println(&quot;规则：rule_halt_2触发&quot;);end (7).getWorkingMemorygetWorkingMemory方法的作用是返回工作内存对象。 123456package testgetWorkingMemoryrule &quot;rule_getWorkingMemory&quot; when then System.out.println(drools.getWorkingMemory());end (8).getRulegetRule方法的作用是返回规则对象。 123456package testgetRulerule &quot;rule_getRule&quot; when then System.out.println(drools.getRule());end 使用在项目中使用Drools时，可以单独使用也可整合spring使用，单独使用,使用以下依赖： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt; &lt;version&gt;10.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-mvel&lt;/artifactId&gt; &lt;version&gt;10.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-xml-support&lt;/artifactId&gt; &lt;version&gt;10.1.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Drools API 开发步骤 获取KieServices 获取KieContainer KieSession Insert fact 触发规则 关闭KieSession 123456789101112131415161718public class DroolsTest{ @BeforeEach public void init() { KieServices kieServices = KieServices.Factory.get(); KieContainer kieContainer = kieServices.newKieClasspathContainer(); kieSession = kieContainer.newKieSession(); } @Test public void test() { BookDiscount bookDiscount = new BookDiscount(); bookDiscount.setOriginalPrice(120.0); kieSession.insert(bookDiscount); kieSession.fireAllRules(); kieSession.dispose(); System.out.println(bookDiscount.getDiscountPrice()); }} SpringBoot 整合Drools 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-mvel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.kie&lt;/groupId&gt; &lt;artifactId&gt;kie-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;","link":"/2025/11/18/Drools%E5%AD%A6%E4%B9%A0/"},{"title":"LangChain4j For Java","text":"调用大模型的JAVA开发框架，相当于JAVA的一个中间件 简介 LangChain4j 的目标是简化将 LLM 集成到 Java 应用程序中的过程。LangChain4j 于2023年初在ChatGPT 的炒作中开始开发，我们注意到，许多 Pvthon 和 JavaScript LUM 库和框架缺乏 Java对应物。我们必须解决这个问题！虽然我们的名字里有”LangChain”，但该项目融合了来自 LangChain、Haystack、 Llamalndex 和更广泛的社区，都加入了我们自己的创新。 功能1.统一API: LLM 提供程序（如 OpenAl 或 Google Vertex AI） 和嵌入（向量）存储（如 Pinecone 或 Milvus）使用专有 APl，以避免为每个API学习和实现特定的API、要试验不同的LLM 或嵌入存储，您可以轻松地在它们之间切换，而无需重写代码。LangChain4j 目前支持 15+ 个流行的LLM 提供商和 20+ 个嵌入商店。 2.综合工具箱: 自2023年初以来，社区一直在构建许多由LLM 提供支持的应用釋序。识别常见的抽象、模式和技术。LangChain4j已将这些改进为一个即用型包。我们的工具箱包括从低级提示模板、聊天内存管理和函数调用等工具到 Agent 和 RAG 等高级模式。对于每个抽象，我们提供了一个接口以及基于通用技术的多个即用型实现。无论您是构建聯天机器人还是开发具有从数据摄取到检索的完整管道的 RAG，LangChain4j提供了多种选择。 LLM大模型应用技术架构 与SpringBoot 整合LangChain4j 提供了2种方式 底层API（popular integrations） 高阶API (declarative AI Services) 底层API Low level. At this level, you have the most freedom and access to all the low-level components such as ChatModel, UserMessage, AiMessage, EmbeddingStore, Embedding, etc. These are the “primitives” of your LLM-powered application. You have complete control over how to combine them, but you will need to write more glue code. 优点 可以使用 ChatModel, UserMessage, AiMessage, EmbeddingStore, Embedding 可以自由组合使用各个组件代码但编码量比较高 chatModel low-level 模型api，提供chat方法用于对话，可以接收单个或多个消息，chatModel提供的一种极其简便的设计方法 高阶API High level. At this level, you interact with LLMs using high-level APIs like AI Services, which hides all the complexity and boilerplate from you. You still have the flexibility to adjust and fine-tune the behavior, but it is done in a declarative manner. 优点 可以使用AiServices、Tools等 可以自己定义接口，通过AiServices类里面的方法实现，优点api封装度比较高，减少了代码的复杂性，但仍可以进行灵活的微调 Token大模型中的Token 与 Web 开发中的Token区别 大模型的token Web 中的Token是用于认证和授权的一种加密字符串 常用的模型参数日志配置https://docs.langchain4j.dev/tutorials/logging 123456789101112131415161718@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public ChatModel alibabaChatMode() { return OpenAiChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .logRequests(true) .logResponses(true) //开启日志 .build(); }} 监控需实现ChatModelListener接口 12345678910111213141516171819202122@Slf4jpublic class ChatListener implements ChatModelListener { @Override public void onRequest(ChatModelRequestContext requestContext) { String traceId = UUID.randomUUID().toString(); requestContext.attributes().put(&quot;traceId&quot;, traceId); log.info(&quot;------&gt; onRequest traceId: {}&quot;, traceId); } @Override public void onResponse(ChatModelResponseContext responseContext) { String traceId = responseContext.attributes().get(&quot;traceId&quot;).toString(); log.info(&quot;------&gt; onResponse traceId: {}&quot;, traceId); } @Override public void onError(ChatModelErrorContext errorContext) { log.info(&quot;------&gt; onError&quot;); }} 进行配置 12345678910111213141516171819@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public ChatModel alibabaChatMode() { return OpenAiChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .logRequests(true) .logResponses(true) //开启日志 .listeners(List.of(new ChatListener())) //监控 .build(); }} 重试机制maxReties 1234567891011121314151617181920@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public ChatModel alibabaChatMode() { return OpenAiChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .logRequests(true) .logResponses(true) //开启日志 .listeners(List.of(new ChatListener())) //监控 .maxRetries(3) //重试 .build(); }} 超时机制Timeout 1234567891011121314151617181920@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public ChatModel alibabaChatMode() { return OpenAiChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .logRequests(true) .logResponses(true) //开启日志 .listeners(List.of(new ChatListener())) //监控 .maxRetries(3) //重试 .timeout(Duration.ofSeconds(3)) // 重试超时时间 .build(); }} ChatMemory 用于记录对话上下文，LLM 根据上下文进行回答 langchain4j 会话淘汰策略有2种 MessageWindowChatMemory 基于消息数量的简单实现，它采用滑动窗口的方式，保留最新的N条消息并淘汰旧消息 TokenWindowChatMemory 基于令牌数量限制，确保模型处理的上下文保持在指定范围内，需要结合TokenCountEstimator 计算ChatMessage的Token数量 提示词 Types of chatMessage ，目前有五种类型的聊天消息，每个消息的来源对应一种 SystemMessage 这是来自系统的消息。通常，作为开发人员，你应该定义这条消息的内容。通常，你会在这里写关于LLM在这次对话中的角色、应该如何表现，以什么风格回答等指令。LLM被训练成比其他类型的消息更关注SystemMessage,所以要小心，最好不要给最终用户自由访问权限来定义或注入一些输入到SystemMessage中。通常，它位于对话的开始。 UserMessage, 这是来自用户的消息。用户可以是你的应用程序的最终用户（一个人）或应用程序本身。根据LLM支持的模态，UserMessage可以只包含文本，或其他模态 AiMessage 这是由AI生成的消息，通常是对UserMessage响应。如你所注意到的，generate方法返回一个包裹在Response中的AiMessage.AiMessage可以包含文本响应，或执行工具的请求 ToolExecutionResultMessage 这是ToolExecutionRequest的结果。 CostomMessage 这是一个自定义消息，可以包含任意属性。这种消息类型只能由支持它的chatModel实现使用目前只有Ollama 作用角色设定：塑造AI助手的专业身份，打造专业的限定能力范围和作用边界的AI助手 Prompt 演化历程 简单纯字符串提问问题 最初Prompt只是简单的文本字符串 占位符 引入占位符如{it}以动态插入内容 多角色消息 将消息分为不同角色（用户、助手、系统等）设置功能边界，增强交互复杂性和上下文感知能力 Tools (Function Calling) 有一个概念被称“工具”或“函数调用”。它允许 LLM 在必要时调用一个或多个可用工具，这些工具通常由开发人员定义。工具可以是任何东西：网络搜索、对外部API的调用，或者执行特定代码片段等。LLMs本身不能实际调用工具；相反，它们在响应中表达调用特定工具的意图（而不是以纯文本回应）。作为开发人员，我们应该根据提供的参数执行此工具，并报告工具执行的结果。 例如，我们知道 LLM 本身并不擅长数学。如果你的应用场景涉及偶尔的数学计算，你可能希望为 LLM 提供一个“数学工具”。通过在请求中声明一个或多个工具给 LLM，它可以决定是否调用其中一个工具如果它认为合适的话。给定一个数学问题和一组数学工具，LLM可能会决定为了正确回答问题，它应该首先调用提供的数学工具之一。 LLM 可以调用外部接口，汇总成用户所需要的答案 代码实现功能: 调用阿里的大模型，匹配关键字，进行自己写的工具调用，最后返回给用户 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Slf4j@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public StreamingChatModel streamingChatModel() { return OpenAiStreamingChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .build(); } @Bean public WeatherService weatherService(StreamingChatModel chatModel) { //根据用户输入出的话，匹配关键字，进行工具调用 //工具定义 ToolSpecification toolSpecification = ToolSpecification.builder() .name(&quot;天气查询&quot;) .description(&quot;城市天气查询&quot;) .parameters(JsonObjectSchema.builder() .addStringProperty(&quot;city&quot;, &quot;城市&quot;) .build()) .build(); //工具调用 可写业务逻辑，同时返回给用户，不再通过大模型处理 //工具实现 ToolExecutor toolExecutor = (toolExecutionRequest, memoryId) -&gt; { log.info(toolExecutionRequest.id()); log.info(toolExecutionRequest.name()); log.info(&quot;argus --&gt; {}&quot;, toolExecutionRequest.arguments()); return &quot;天气为雨天&quot;; }; return AiServices.builder(WeatherService.class) .streamingChatModel(chatModel) .tools(Map.of(toolSpecification, toolExecutor)) .build(); }} 天气查询接口 1234public interface WeatherService { Flux&lt;String&gt; chat(String message);} 向量化存储向量 Vector 是向量或矢量的意思，向量是数学的概念，而矢量是物理的概念，但二者描述的是同一件事。向量是用于表示具有大小和方向的量。向量可以在不同的维度空间中定义，最常见的是二维和三维空间中的向量，但理论上也可以有更高维的向量。例如，在二维平面上的一个向量可以写作（x,y），这里x和y分别表示该向量沿两个坐标轴方向上的分量；而在三维空间里，则会有一个额外的z坐标，即（x,y,z）。 向量化将文字通过向量模型转成向量化数据 LangChain4j 向量化3件套1. Embedding Model嵌入（Embedding）的工作原理是将文本、图像和视频转换为称为向量（Vectors）的浮点数数组。这些向量旨在捕捉文本、图像和视频的含义。嵌入数组的长度称为向量的维度 （Dimensionality）。嵌入模型（EmbeddingModel ）是嵌入过程中采用的模型。当前EmbeddingModel的接口主要用于将文本转换为数值向量，接口的设计主要围绕这两个目标展开： 可移植性：该接口确保在各种嵌入模型之间的轻松适配。它允许开发者在不同的嵌入技术或模型之间切换，所需的代码更改最小化。这一设计与 Spring 模块化和互换性的理念一致。 简单性：嵌入模型简化了文本转换为嵌入的过程。通过提供如 embed（String text） 和 embed（Documentdocument） 这样简单的方法，它去除了处理原始文本数据和嵌入算法的复杂性。这个设计选择使开发者，尤其是那些初次接触AI 的开发者，更容易在他们的应用程序中使用嵌入，而无需深入了解其底层机制。 2. Embedding Store向量存储（vectorstore）是一种用于存储和检索高维向量数据的数据库或存储解决方案，它特别适用于处理那些经过嵌入模型转化后的数据。在 VectorStore 中，查询与传统关系数据库不同。它们执行相似性搜索，而不是精确匹配。当给定一个向量作为查询时，VectorStore 返回与查询向量“相似”的向量。VectorStore 用于将您的数据与 AI 模型集成。在使用它们时的第一步是将您的数据加载到矢量数据库中。然后，当要将用户查询发送到 AI模型时，首先检索一组相似文档。然后，这些文档作为用户问题的上下文，并与用户的查询一起发送到 AI模型。这种技术被称为检索增强生成（Retrieval AugmentedGeneration，RAG）。 3. EmbeddingSearchRequest向量查询请求，可以查询向量数据库 作用 将文本、图像和视频转为向量的浮点数数组在VectorStore中，与传统关系数据库不同，它们执行相似性搜索，不是精确匹配。当给定一个向量作为查询时，VectorStore返回与查询向量相似的向量 特点： 捕捉复杂的词汇关系 超越传统词袋模型的简单计数方式 动态嵌入模型(如 BERT) 可根据上下文生成不同的词向量 向量嵌入为现代搜索和检索增强生成（RAG）应用程序提供支持 代码通过大模型向向量数据库Qdrant写入数据LangChain4j 配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public StreamingChatModel streamingChatModel() { return OpenAiStreamingChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .build(); } @Bean public EmbeddingModel embeddingModel() { return OpenAiEmbeddingModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;text-embedding-v4&quot;) .build(); } /** * Qdrant 数据库配置 */ @Bean public QdrantClient getQdrantClient() { return new QdrantClient(QdrantGrpcClient.newBuilder(&quot;localhost&quot;, 6334, false).build()); } /** * 向量存储配置 */ @Bean public EmbeddingStore&lt;TextSegment&gt; embeddingStore(QdrantClient qdrantClient) { return QdrantEmbeddingStore.builder() .client(qdrantClient) .collectionName(&quot;test-qdrant&quot;) .build(); }} 向量Controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Slf4j@RequestMapping(&quot;/api/embedding-store&quot;)@RestController@RequiredArgsConstructorpublic class EmbedStoreController { private final EmbeddingModel embeddingModel; private final EmbeddingStore&lt;TextSegment&gt; embeddingStore; private final QdrantClient qdrantClient; @GetMapping(&quot;/get&quot;) public String getEmbeddingStoreStr(String message) { TextSegment segment1 = TextSegment.from(message); Response&lt;Embedding&gt; embed = embeddingModel.embed(segment1); log.info(&quot;Embedding added: {}&quot;, embed.content()); return embed.content().toString(); } @GetMapping(&quot;/create-collection&quot;) public void createCollection() { try { Collections.CollectionOperationResponse collectionOperationResponse = qdrantClient.createCollectionAsync(&quot;test-qdrant&quot;, Collections.VectorParams.newBuilder() .setDistance(Collections.Distance.Cosine) .setSize(1024) .build()).get(); log.info(collectionOperationResponse.toString()); } catch (Exception e) { log.error(e.getMessage(), e); } } @GetMapping(&quot;/delete-collection&quot;) public void deleteCollection() { try { Collections.CollectionOperationResponse collectionOperationResponse = qdrantClient.deleteCollectionAsync(&quot;test-qdrant&quot;).get(); log.info(collectionOperationResponse.toString()); } catch (Exception e) { log.error(e.getMessage(), e); } } @GetMapping(&quot;/add&quot;) public String add() { TextSegment segment = TextSegment.from(&quot;Hello World&quot;); segment.metadata().put(&quot;id&quot;, &quot;first&quot;); Embedding embedding = embeddingModel.embed(segment).content(); String result = embeddingStore.add(embedding, segment); log.info(result); return result; } @GetMapping(&quot;/query&quot;) public String query() { TextSegment segment = TextSegment.from(&quot;World&quot;); Embedding embedding = embeddingModel.embed(segment).content(); EmbeddingSearchRequest searchRequest = EmbeddingSearchRequest.builder() .queryEmbedding(embedding) .maxResults(1) .build(); EmbeddingSearchResult&lt;TextSegment&gt; search = embeddingStore.search(searchRequest); if (!CollectionUtils.isEmpty(search.matches())) { return search.matches().get(0).embedded().text(); } return null; } @GetMapping(&quot;/query2&quot;) public String query2() { TextSegment segment = TextSegment.from(&quot;d&quot;); Embedding embedding = embeddingModel.embed(segment).content(); EmbeddingSearchRequest searchRequest = EmbeddingSearchRequest.builder() .filter(new IsEqualTo(&quot;id&quot;, &quot;first&quot;)) .queryEmbedding(embedding) .maxResults(1) .build(); EmbeddingSearchResult&lt;TextSegment&gt; search = embeddingStore.search(searchRequest); if (!CollectionUtils.isEmpty(search.matches())) { return search.matches().get(0).embedded().text(); } return null; }} 检索增强生成RAG LLM 的知识仅限于它所接受的训练数据。如果你想一个LLM了解特定领域的知识或专有数据数据，可以使用RAG。简单来说，RAG（检索增强生成）是一种从你的数据中查找相关信息，并在将提示发送给LLM之前将其注入到提示中的方法。这样一来，LLM就能获得相关的信息，并基于这些信息进行回答，从而降低产生幻觉的概率RAG 技术就像给AI大模型装上了实时百科大脑，为了让大模型获取足够的上下文，以便获得更加广泛的信息源，通过先查资料后回答的机制，让AI摆脱传统模型的知识遗忘的幻觉回复困境 注：幻觉-已读乱回，已读不回，答非所问 作用通过引入外部知识源来增强LLM的输出能力，传统的LLM通常基于其训练数据生成响应，但这些数据可能过时或不够全面。RAG允许模型在生成答案之前，从特定的知识库中检索相关信息，从而提供更准确和上下文相关的回答 使用RAG 流程分为两个不同的阶段：索引和检索 1.index将文件分成多个分片，通过向量模型，转换成向量数据，写入到向量数据库中 2.Retrieval LangChain4j RAG组成1. EmbeddingStoreIngestor 组织结构分析 1234567891011public class EmbeddingStoreIngestor { private static final Logger log = LoggerFactory.getLogger(EmbeddingStoreIngestor.class); private final DocumentTransformer documentTransformer; //文档转换 private final DocumentSplitter documentSplitter; //文档分割 private final TextSegmentTransformer textSegmentTransformer; //转换单个文本段落（例如：用于标准化或清理） private final EmbeddingModel embeddingModel; //为文本段落向量化 private final EmbeddingStore&lt;TextSegment&gt; embeddingStore; //存储生成的嵌入向量及其对应的文件段落} 2. Document Loader 文档加载器 FileSystemDocumentLoader： 从文件系统加载文 UrlDocumentLoader： 从 URL 加载文档 AmazonS3DocumentLoader： 从 Amazon S3 加载文档 AzureBlobStorageDocumentLoader： 从 Azure Blob 存储加载文档 GitHubDocumentLoader： 从 GitHub 仓库加载文档 TencentCosDocumentLoader： 从腾讯云 COS 加载文档 3. Document Parser 文档解析器Documents can represent files in various formats, such as PDF, DOC, TXT, etc. To parse each of these formats, there’s a DocumentParser interface with several implementations included in the library: TextDocumentParser from the langchain4j module, which can parse files in plain text format (e.g. TXT, HTML, MD, etc.)ApachePdfBoxDocumentParser from the langchain4j-document-parser-apache-pdfbox module, which can parse PDF files ApachePoiDocumentParser from the langchain4j-document-parser-apache-poi module, which can parse MS Office file formats (e.g. DOC, DOCX, PPT, PPTX, XLS, XLSX, etc.) ApacheTikaDocumentParser from the langchain4j-document-parser-apache-tika module, which can automatically detect and parse almost all existing file formats **总结：**用于解析各种文件类型的，推荐使用ApacheTikaDocumentParser，能够解析市面上大部分文件类型。 4. Document Transformer 文档转换器 用于对文档执行各种转换，如清理、过滤、增强或总结。 5. Document Splitter 文档拆分器 DocumentByParagraphSplitter： 按段落拆分 DocumentBySentenceSplitter： 按句子拆分 DocumentByWordSplitter： 按单词拆分 DocumentByCharacterSplitter： 按字符拆分 DocumentByRegexSplitter： 按正则表达式拆分 构建RAG的一般步骤 加载文档：使用适当的 DocumentLoader 和 DocumentParser加载文档 转换文档：使用 DocumentTransformer清理或增强文档（可选） 拆分文档：使用 Documentsplitter 将文档拆分为更小的片段（可选） 嵌入文档：使用 EmbeddingModel 将文档片段转换嵌入向量 存储嵌入：使用 EmbeddingStoreIngestor 存储嵌入向量 检索相关内容：根据用户查询，从 Embeddingstore 检索最相关的文档片段 生成响应：将检索到的相关内容与用户查询一起提供给语言模型，生成最终响应 代码功能：解析一份文件，将文件的数据存入向量数据库中，再对大模型进行文件内容提问，大模型会查询向量数据库，进行回答。 LLM 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Slf4j@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public StreamingChatModel streamingChatModel() { return OpenAiStreamingChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .build(); } @Bean public EmbeddingModel embeddingModel() { return OpenAiEmbeddingModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;text-embedding-v4&quot;) .build(); } @Bean public QdrantClient getQdrantClient() { return new QdrantClient(QdrantGrpcClient.newBuilder(&quot;localhost&quot;, 6334, false).build()); } @Bean public EmbeddingStore&lt;TextSegment&gt; embeddingStore(QdrantClient qdrantClient) { return QdrantEmbeddingStore.builder() .client(qdrantClient) .collectionName(&quot;test-qdrant&quot;) .build(); } @Bean public EasyRagService easyRagService(StreamingChatModel streamingChatModel, EmbeddingStore&lt;TextSegment&gt; embeddingStore, EmbeddingModel embeddingModel) { //检索时的配置 ContentRetriever contentRetriever = EmbeddingStoreContentRetriever.builder() .embeddingStore(embeddingStore) .embeddingModel(embeddingModel) .build(); return AiServices.builder(EasyRagService.class) .streamingChatModel(streamingChatModel) .chatMemory(MessageWindowChatMemory.withMaxMessages(100)) .contentRetriever(contentRetriever) .build(); }} 业务层 123public interface EasyRagService { Flux&lt;String&gt; chat(String message);} controller 层 123456789101112131415161718192021222324252627282930313233@RequestMapping(&quot;/api/rag&quot;)@Slf4j@RequiredArgsConstructor@RestControllerpublic class RagController { private final EasyRagService easyRagService; private final EmbeddingStore&lt;TextSegment&gt; embeddingStore; private final EmbeddingModel embeddingModel; @GetMapping(&quot;/easy&quot;) public Flux&lt;String&gt; chat(String message) { ClassPathResource classPathResource = new ClassPathResource(&quot;easyRag.txt&quot;); Document document = null; try { //load file document = FileSystemDocumentLoader.loadDocument(Paths.get(classPathResource.getURL().toURI()), new ApacheTikaDocumentParser()); } catch (Exception e) { throw new RuntimeException(e); } //build store EmbeddingStoreIngestor embeddingStoreIngestor = EmbeddingStoreIngestor .builder() .embeddingModel(embeddingModel) .embeddingStore(embeddingStore) .build(); embeddingStoreIngestor.ingest(document); return easyRagService.chat(message); }} MCP(模型上下文协议) MCP （Model Context Protocol）是一种开放协议，它标准化了应用程序如何向大型语言模型提供上下文，可以将MCP想像成AI应用的USB-C端口。它像USB-C提供了一种标准化的方式将你的设备连接到各种外围设备一样，MCP提供了一种标准化的方式将AI模型连接到不同的数据源和工具。https://modelcontextprotocol.io/docs/getting-started/intro 作用提供了一种标准化的方式来连接LLMs需要的上下文，MCP就类似于一个Agent时代的Type-C协议，希望能将不同来源的数据、工具、服务统一起来来供大模型调用，MCP 就是比FunctionCalling的更高一级的抽象，也是实现智能体Agent的基础。 架构 MCP 遵循客户端-服务端架构包含以下几个核心部分 MCP 主机(MCP Hosts) MCP 客户端（MCP Clients） MCP 服务器(MCP Servers) 本地资源(Local Resources) 远程资源(Remote Resources) MCP 通信协议 ​Server-Sent Events (SSE)：支持使用HTTP POST请求进行服务器到客户端流式处理，以实现客户端到服务器的通信 STDIO (Standard Input/Output)：支持标准输入和输出流进行通信，主要用于本地集成、命令行工具等场景两者差异 代码查询当前时间，大模型不支持查询当前时间，通过mcp服务调用使用的是time mcp 服务（https://mcp.so/server/time/modelcontextprotocol） 接口 123public interface McpService { Flux&lt;String&gt; chat(String message);} 配置 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class LLMConfig { @Value(&quot;${alibaba-api-key}&quot;) private String apiKey; @Bean public StreamingChatModel alibabaChatMode() { return OpenAiStreamingChatModel.builder() .apiKey(apiKey) .baseUrl(&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;) .modelName(&quot;qwen-turbo&quot;) .build(); } @Bean public McpService getMcpService(StreamingChatModel streamingChatModel) { //调用mcp 时间 server 参数 McpTransport transport = new StdioMcpTransport.Builder() .command(List.of(&quot;uvx&quot;, &quot;mcp-server-time&quot;, &quot;--local-timezone=Asia/Shanghai&quot;)) .build(); //构建mcp client McpClient mcpClient = new DefaultMcpClient.Builder() .key(&quot;timeClient&quot;) .transport(transport) .build(); McpToolProvider toolProvider = McpToolProvider.builder() .mcpClients(mcpClient) .build(); return AiServices .builder(McpService.class) .streamingChatModel(streamingChatModel) .toolProvider(toolProvider) .build(); }} 调用 1234567891011121314@RestController@RequestMapping(&quot;/api/mcp&quot;)@Slf4j@RequiredArgsConstructorpublic class McpController { private final McpService mcpService; @GetMapping(&quot;&quot;) public Flux&lt;String&gt; mcp(String message) { return mcpService.chat(message); }} 总结 Function Calling,为了让大模型使用Util工具 RAG,为了让大模型获取足够的上下文 MCP，为了让大模型之间调用 完整代码LangChain4j Demo","link":"/2025/07/23/LangChain4j-for-java/"},{"title":"Lombok学习","text":"前言自从进公司工作之后，在项目中，查看项目代码时发现了一个之前没有遇到的注解@Data，于是Google了下才弄清楚，故记录下来 。 Lombok 简介Lombok是一个编译级别的插件，它可以在项目编译的时候生成一些代码。在项目开发时，要用到简单的 Java 对象(POJO)，而在类中需要写许多的属性，并且要对属性进行getter、setter、toString和equals方法，通过Lombok可以消除 Java 的冗长代码。 Lombok 安装1.引入Lombok的 jar 包,在 maven 中直接添加依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 2.装插件 如果用的是 IDEA 的话，需要装插件，不然 IDEA 不识别，在 IDEA 插件中搜索 Lombok 即可 3.在 IDEA 中启用 annotation processors Lombok 常用注解用法@NonNull 作用: 空检查 @Cleanup 作用：在变量上声明 @Cleanup，生成的代码会把变量用 try-catch 包围，并在 finally 块中调用 close() 例子 12345678910111213141516public class Example { public void testCleanUp(String in, String out) throws IOException { @Cleanup FileInputStream inputStream = new FileInputStream(in); @Cleanup FileOutputStream outputStream = new FileOutputStream(out); byte[] b = new byte[1024]; int len; while ((len = inputStream.read(b)) != -1){ outputStream.write(b, 0 ,len); } outputStream.close(); inputStream.close(); }} 生成后 1234567891011121314151617181920212223242526272829303132333435public class Example { public Example() { } public void testCleanUp(String in, String out) throws IOException { FileInputStream inputStream = new FileInputStream(in); try { FileOutputStream outputStream = new FileOutputStream(out); try { byte[] b = new byte[1024]; boolean var6 = false; int len; while((len = inputStream.read(b)) != -1) { outputStream.write(b, 0, len); } outputStream.close(); inputStream.close(); } finally { if (Collections.singletonList(outputStream).get(0) != null) { outputStream.close(); } } } finally { if (Collections.singletonList(inputStream).get(0) != null) { inputStream.close(); } } }} @Getter/@Setter/@ToString 作用：为属性生成 get、 set和toString方法 例子 123456@ToStringpublic class Person { @Setter @Getter private String name;} 生成后 123456789101112131415161718public class Person { private String name; public Person() { } public String toString() { return &quot;Person(name=&quot; + this.getName() + &quot;)&quot;; } public void setName(String name) { this.name = name; } public String getName() { return this.name; }} @EqualsAndHashCode 作用：生成 hashCode() 、equals() 例子 1234567@EqualsAndHashCode@ToStringpublic class Person { @Setter @Getter private String name;} 生成后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Person { private String name; public Person() { } public boolean equals(Object o) { if (o == this) { return true; } else if (!(o instanceof Person)) { return false; } else { Person other = (Person)o; if (!other.canEqual(this)) { return false; } else { Object this$name = this.getName(); Object other$name = other.getName(); if (this$name == null) { if (other$name != null) { return false; } } else if (!this$name.equals(other$name)) { return false; } return true; } } } protected boolean canEqual(Object other) { return other instanceof Person; } public int hashCode() { int PRIME = true; int result = 1; Object $name = this.getName(); int result = result * 59 + ($name == null ? 43 : $name.hashCode()); return result; } public String toString() { return &quot;Person(name=&quot; + this.getName() + &quot;)&quot;; } public void setName(String name) { this.name = name; } public String getName() { return this.name; }} @NoArgsConstroctor / @AllArgsConstroctor 作用：生成无参的构造器和有参构造器 例子 12345@NoArgsConstructor@AllArgsConstructorpublic class Person { private String name;} 生成后 12345678910public class Person { private String name; public Person() { } public Person(String name) { this.name = name; }} @Data 作用：生成所有字段的 getter、toString()、hashCode()、equals、所有非 final 字段的 setter、构造器，相当于设置了 @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 例子 12345@Datapublic class Person { private String name;} 生成后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Person { private String name; public Person() { } public String getName() { return this.name; } public void setName(String name) { this.name = name; } public boolean equals(Object o) { if (o == this) { return true; } else if (!(o instanceof Person)) { return false; } else { Person other = (Person)o; if (!other.canEqual(this)) { return false; } else { Object this$name = this.getName(); Object other$name = other.getName(); if (this$name == null) { if (other$name != null) { return false; } } else if (!this$name.equals(other$name)) { return false; } return true; } } } protected boolean canEqual(Object other) { return other instanceof Person; } public int hashCode() { int PRIME = true; int result = 1; Object $name = this.getName(); int result = result * 59 + ($name == null ? 43 : $name.hashCode()); return result; } public String toString() { return &quot;Person(name=&quot; + this.getName() + &quot;)&quot;; }} @Builder 作用：生成构建者(Builder) 模式 例子 1234567@Builderpublic class Person { private final String name; private final String sex; private int weight;} 生成后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.zk.builder;public class Person { private final String name; private final String sex; private int weight; Person(String name, String sex, int weight) { this.name = name; this.sex = sex; this.weight = weight; } public static Person.PersonBuilder builder() { return new Person.PersonBuilder(); } public static class PersonBuilder { private String name; private String sex; private int weight; PersonBuilder() { } public Person.PersonBuilder name(String name) { this.name = name; return this; } public Person.PersonBuilder sex(String sex) { this.sex = sex; return this; } public Person.PersonBuilder weight(int weight) { this.weight = weight; return this; } public Person build() { return new Person(this.name, this.sex, this.weight); } public String toString() { return &quot;Person.PersonBuilder(name=&quot; + this.name + &quot;, sex=&quot; + this.sex + &quot;, weight=&quot; + this.weight + &quot;)&quot;; } }} 参数 builderMethodName: 创建构建器实例的方法名称 buildMethodName: 构建器类中创建构造器实例的方法名称 builderClassName: 构造器类名 toBuilder: 生成toBuilder 方法 总结Lombok 有助于代码的整洁、效率的提高以及冗余的减少。 上面的注解都是在项目中经常用到的，同时在学习过程中碰到了建造者设计模式，下一篇再记录一下建造者模式。","link":"/2019/06/29/Lombok%E5%AD%A6%E4%B9%A0/"},{"title":"Docker 常用命令","text":"梳理并总结日常使用的 Docker 命令 镜像操作命令 检索 1docker search 镜像 下载 1docker pull 镜像 查看镜像列表 1docker images 删除镜像 1docker rmi 镜像名/ID 加载镜像 1234 docker load [OPTIONS] -i, --input string Read from tar archive file, instead of STDIN -q, --quiet Suppress the load outputdocker load -i test.tar 容器操作命令 容器运行 123456docker run 相关参数-p 主机端口:容器端口-v 主机目录：容器目录-e 容器服务配置参数-d 后台运行--name 容器命名 容器查看 1docker ps 容器停止 1docker stop container name 容器启动 1docker start container name 容器重启 1docker restart container name 容器状态可以查看内存、cpu等使用情况 1docker stats 容器日志 1docker logs container name 进入容器 1docker exec -it container name /bin/bash 容器删除 1docker rm container name 容器复制 12docker cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATHdocker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH 从容器复制文件到宿主机 1docker cp my_container:/path/in/container /path/on/host 从宿主机复制文件到容器 1docker cp /path/on/host my_container:/path/in/container 容器提交 12docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]docker commit -a &quot;elliot&quot; -m &quot;test&quot; 3f4e86d6e1ba test:1.0 容器保存 12docker save [OPTIONS] IMAGE [IMAGE...]docker save -o alist-189.tar alist-189:1.0 卷映射可以容器启动时使用，将容器中的配置文件挂载到本地目录中-v config:/user/config其中config 目录默认存在: /var/lib/docker/volumes/&lt;volume-name&gt; 查看卷映射 1docker volume -ls 分享镜像，上传至Docker Hub 登录docker hub 1docker login 重命名镜像名用户名（docker hub的用户名）/镜像名 1docker tag test/test:latest dockerhub用户名/test:1.0 上传到Docker Hub 1docker push dockerhub用户名/test:1.0 自定义网络创建网络 1docker network create 网络名 Compose Docker Compose 让你通过一个 YML 文件，轻松启动多个服务，比如 Web 服务、数据库、缓存等。 示例参数配置文档https://docs.docker.com/reference/compose-file/ 12345678910111213141516171819202122232425262728name: blogservices: mysql: image: mysql:latest container_name: mysql-blog restart: always ports: - 3306:3306 networks: - blog environment: MYSQL_ROOT_PASSWORD: qwe123 MYSQL_DATABASE: wordpress wordpress: image: wordpress:latest container_name: wordpress-blog ports: - 8080:80 networks: - blog restart: always environment: WORDPRESS_DB_NAME: wordpress WORDPRESS_DB_CHARSET: utf8 WORDPRESS_DB_COLLATE: utf8_general_ci WORDPRESS_DB_HOST: mysql-blog WORDPRESS_DB_USER: root WORDPRESS_DB_PASSWORD: qwe123 启动compose文件中的服务 123docker compose [OPTIONS] COMMAND后台起动服务docker compose -f compose.yaml up -d 删除并移除容器 1docker compose -f compose.yaml down DockerFile 制作镜像 Dockerfile 是一个文本文件，其中包含了一组指令（命令），这些指令定义了如何构建一个 Docker 镜像。 https://docs.docker.com/reference/dockerfile/ 指令 作用 FROM 基础镜像，比如 ubuntu, node, openjdk 等 WORKDIR 设置工作目录 COPY 把宿主机文件复制进镜像中 RUN 构建时执行命令（如 RUN apt install ...） CMD 或 ENTRYPOINT 容器启动时执行的命令 EXPOSE 声明容器监听的端口（文档作用） LABEL 自定义标签 ENV 环境变量 ADD 添加文件到镜像 VOLUME 数据卷 USER 指定用户和用户组 ARG 指定构建参数 制作镜像示例 123456789FROM openjdk:17LABEL author=elliotCOPY ./langchain4j-chat-mcp-1.0-SNAPSHOT.jar /langchain4j-chat-mcp-1.0-SNAPSHOT.jarEXPOSE 9014ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/langchain4j-chat-mcp-1.0-SNAPSHOT.jar&quot;] 构建命令 1docker build -f Dockerfile -t langchain4j-mcp:1.0 . DockerFile 镜像分层机制 镜像与容器的关系 多个容器与镜像的关系","link":"/2025/08/04/docker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Hello World","text":"其实早想搭建博客了，只是一直没有时间，主要是懒，以前写的技术型文章都在朋友博客里，有时间在再整理一下，发布到这里;还有几个月要毕业了，博客算是一个新的开始吧，以后所见所想所学都会记录在博客里，算是自己一块领地吧。 感谢Litten提供的Yilia主题，主题比较简洁，色调不错。","link":"/2019/04/21/hello-world/"},{"title":"设计模式之设计原则","text":"设计模式设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码的设计经验的总结。简单的来讲，就是许多软件工程师经过多年编码经验总结的一套编程规范。 设计原则设计原则是指导我们代码设计的一些经验总结。 6 大设计原则 单一职责原则（Single Responsibility Principle） 开闭原则（Open Close Principle） 里式替换原则（Liskov Substitution Principle） 接口隔离原则（Interface Segregation Principle） 依赖倒置原则（Dependence Inversion Principle） 迪米特原则（Law of Demeter） 单一职责原则","link":"/2020/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],"tags":[{"name":"规则引擎框架","slug":"规则引擎框架","link":"/tags/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[],"pages":[]}